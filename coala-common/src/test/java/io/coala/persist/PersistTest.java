/* $Id$
 * 
 * Part of ZonMW project no. 50-53000-98-156
 * 
 * @license
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy
 * of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 * 
 * Copyright (c) 2016 RIVM National Institute for Health and Environment 
 */
package io.coala.persist;

import java.sql.SQLException;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.EntityManagerFactory;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;

import org.aeonbits.owner.ConfigCache;
import org.apache.logging.log4j.Logger;
import org.junit.Test;

import io.coala.config.ConfigUtil;
import io.coala.json.JsonUtil;
import io.coala.log.LogUtil;

/**
 * {@link PersistTest}
 * 
 * @version $Id$
 * @author Rick van Krevelen
 */
public class PersistTest
{
	/** */
	private static final Logger LOG = LogUtil.getLogger( PersistTest.class );

	private static final String ENTITY_NAME = "REGISTRATION";

	interface MyHypersonicConfig extends JDBCConfig
	{
		@DefaultValue( "org.hsqldb.jdbc.JDBCDriver" )
		String driver();

//		@DefaultValue( "jdbc:mysql://localhost/testdb" )
//		@DefaultValue( "jdbc:hsqldb:mem:mymemdb" )
		@DefaultValue( "jdbc:hsqldb:file:target/testdb" )
		String url();

		@DefaultValue( "SA" )
		String username();

		@DefaultValue( "" )
		String password();
	}

	@Test
	public void testJDBC() throws SQLException
	{
		final MyHypersonicConfig conf = ConfigCache
				.getOrCreate( MyHypersonicConfig.class );
		final String qry0 = "CREATE TABLE IF NOT EXISTS "//
				+ ENTITY_NAME + " ("//
				+ " id INTEGER GENERATED BY DEFAULT AS IDENTITY(START WITH 1) PRIMARY KEY" //
				+ ", first VARCHAR(255) " //
				+ ", last VARCHAR(255) " //
				+ " )";
		conf.execute( qry0, rs ->
		{
			LOG.trace( "Created table: {} -> {}", qry0,
					JDBCUtil.toString( rs ) );
		} );

		final String qry1 = "TRUNCATE TABLE " + ENTITY_NAME;
		conf.execute( qry1, rs ->
		{
			LOG.trace( "Cleared table: {} -> {}", qry1,
					JDBCUtil.toString( rs ) );
		} );

		final String qry2 = "INSERT INTO " + ENTITY_NAME //
				+ " (first, last) VALUES " //
				+ "('Rick','van Krevelen')" //
				+ ", ('Joram','Hoogink')";
		conf.execute( qry2, rs ->
		{
			LOG.trace( "Filled table: {} -> {}", qry2,
					JDBCUtil.toString( rs ) );
		} );

		final String qry3 = "SELECT * FROM " + ENTITY_NAME;
		conf.execute( qry3, rs ->
		{
			LOG.trace( "Read table: {} -> {}", qry3, JDBCUtil.toString( rs ) );
		} );
	}

	interface MyHibernateConfig extends KunderaJPAConfig
	{
		@DefaultValue( "kundera_test_pu" )
		String[] persistenceUnitNames();

//		@Key( "hibernate.dialect" )
//		@DefaultValue( "org.hibernate.dialect.HSQLDialect" )
//		String hibernateDialect();

//		@Key( "hibernate.default_schema" )
		@DefaultValue( "MY_SCHEMA" )
		String hibernateDefaultSchema();

		@Key( "hibernate.connection.provider_class" )
		@DefaultValue( "org.hibernate.hikaricp.internal.HikariCPConnectionProvider" )
		String hibernateConnectionProviderClass();

		// see https://github.com/brettwooldridge/HikariCP/wiki/Configuration#popular-datasource-class-names
		@Key( "hibernate.hikari.dataSourceClassName" )
		@DefaultValue( "org.hsqldb.jdbc.JDBCDataSource" )
		String hikariDataSourceClass();

		@Key( "hibernate.hikari.dataSource.url" )
//		@DefaultValue( "jdbc:mysql://localhost/testdb" )
//		@DefaultValue( "jdbc:hsqldb:mem:mymemdb" )
		@DefaultValue( "jdbc:hsqldb:file:target/testdb" )
		String url();

		@Key( "hibernate.hikari.dataSource.user" )
		@DefaultValue( "sa" )
		String username();

		@Key( "hibernate.hikari.dataSource.password" )
		@DefaultValue( "" )
		String password();
	}

	@Entity( name = ENTITY_NAME )
	public static class MyRegistration
	{
		@Id
		@GeneratedValue //( strategy = GenerationType.IDENTITY )
		@Column( name = "ID" )
		public int id;

//		@Version
//		@Column( name = "version" )
//		private int version = 0;

		@Column( name = "FIRST", length = 255 )
		public String first;

		@Column( name = "LAST", length = 255 )
		public String last;

		public String toString()
		{
			return getClass().getSimpleName() + JsonUtil.stringify( this );
		}

		public static MyRegistration of( final String first, final String last )
		{
			final MyRegistration result = new MyRegistration();
			result.first = first;
			result.last = last;
			return result;
		}
	}

	@Test
	public void testJPA() throws Exception
	{
		final MyHibernateConfig conf = ConfigCache
				.getOrCreate( MyHibernateConfig.class );
		LOG.trace( "Testing JPA config: {}", ConfigUtil.export( conf ) );
		final EntityManagerFactory emf = conf.createEntityManagerFactory();
		JPAUtil.session( emf, em ->
		{
			final int res0 = em
					.createQuery( "DELETE FROM " + ENTITY_NAME + " r" )
					.executeUpdate();
			LOG.trace( "Removed records: {}", res0 );
		} );
		JPAUtil.session( emf, em ->
		{
			em.persist( MyRegistration.of( "Rick", "van Krevelen" ) );
			em.persist( MyRegistration.of( "Joram", "Hoogink" ) );
			LOG.trace( "Filled table" );
		} );
		JPAUtil.session( emf, em ->
		{
			LOG.trace( "Read table, result: {}",
					em.createQuery( "SELECT r FROM " + ENTITY_NAME + " r",
							MyRegistration.class ).getResultList() );
		} );
		emf.close();
	}
}
